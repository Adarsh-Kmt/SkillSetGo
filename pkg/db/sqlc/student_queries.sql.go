// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: student_queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getJobs = `-- name: GetJobs :many
SELECT job_id, job_role, ctc, salary_tier, apply_by_date, cgpa_cutoff, company_name, industry
FROM job_table LEFT JOIN company_table
on job_table.company_id = company_table.company_id
where (array_length($2::VARCHAR[], 1) = 0 OR salary_tier = ANY($2))
and NOW() < apply_by_date
and cgpa_cutoff <= (SELECT cgpa from student_table where student_id = $1)
`

type GetJobsParams struct {
	StudentID int32    `json:"student_id"`
	Column2   []string `json:"column_2"`
}

type GetJobsRow struct {
	JobID       int32            `json:"job_id"`
	JobRole     string           `json:"job_role"`
	Ctc         float32          `json:"ctc"`
	SalaryTier  string           `json:"salary_tier"`
	ApplyByDate pgtype.Timestamp `json:"apply_by_date"`
	CgpaCutoff  float32          `json:"cgpa_cutoff"`
	CompanyName *string          `json:"company_name"`
	Industry    *string          `json:"industry"`
}

func (q *Queries) GetJobs(ctx context.Context, arg GetJobsParams) ([]*GetJobsRow, error) {
	rows, err := q.db.Query(ctx, getJobs, arg.StudentID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetJobsRow
	for rows.Next() {
		var i GetJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.JobRole,
			&i.Ctc,
			&i.SalaryTier,
			&i.ApplyByDate,
			&i.CgpaCutoff,
			&i.CompanyName,
			&i.Industry,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
